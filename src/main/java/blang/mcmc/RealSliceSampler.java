package blang.mcmc;

import java.util.List;
import bayonet.distributions.Random;

import blang.core.LogScaleFactor;
import blang.core.WritableRealVar;


public class RealSliceSampler implements Sampler
{
  @SampledVariable
  protected WritableRealVar variable;
  
  @ConnectedFactor
  protected List<LogScaleFactor> numericFactors;
  
  private static final double initialWindowSize = 1.0;
  
  public void execute(Random random)
  {
    // sample slice
    final double logSliceHeight = nextSliceHeight(random); // log(Y) in Neal's paper
    final double oldState = variable.doubleValue();        // x0 in Neal's paper
   
    // doubling procedure
    double 
      leftProposalEndPoint = oldState - initialWindowSize * random.nextDouble(), // L in Neal's paper
      rightProposalEndPoint = leftProposalEndPoint + initialWindowSize;          // R in Neal's paper
    
    while (logSliceHeight < logDensityAt(leftProposalEndPoint) || logSliceHeight < logDensityAt(rightProposalEndPoint)) 
      if (random.nextBernoulli(0.5))
        leftProposalEndPoint += - (rightProposalEndPoint - leftProposalEndPoint);
      else
        rightProposalEndPoint += rightProposalEndPoint - leftProposalEndPoint;
    
    // shrinkage procedure
    double 
      leftShrankEndPoint = leftProposalEndPoint,   // bar L in Neal's paper
      rightShrankEndPoint = rightProposalEndPoint; // bar R in Neal's paper
    while (true) 
    {
      final double newState = nextUniform(random, leftShrankEndPoint, rightShrankEndPoint); // x1 in Neal's paper
      if (logSliceHeight < logDensityAt(newState) && accept(oldState, newState, logSliceHeight, leftProposalEndPoint, rightProposalEndPoint))
      {
        variable.set(newState);
        return;
      }
      if (newState < oldState)
        leftShrankEndPoint = newState;
      else
        rightShrankEndPoint = newState;
    }
  }
  
  private boolean accept(double oldState, double newState, double logSliceHeight, double leftProposalEndPoint, double rightProposalEndPoint) 
  {
    boolean differ = false; // D in Neal's paper; whether the intervals generated by new and old differ; used for optimization
    while (rightProposalEndPoint - leftProposalEndPoint > 1.1 * initialWindowSize) // 1.1 factor to cover for numerical round offs
    {
      final double middle = (leftProposalEndPoint + rightProposalEndPoint) / 2.0; // M in Neal's paper
      if ((oldState <  middle && newState >= middle) || 
          (oldState >= middle && newState < middle))
        differ = true;
      if (newState < middle)
        rightProposalEndPoint = middle;
      else
        leftProposalEndPoint = middle;
      if (differ && logSliceHeight >= logDensityAt(leftProposalEndPoint) && logSliceHeight >= logDensityAt(rightProposalEndPoint))
        return false;
    }
    return true;
  }

  private double nextSliceHeight(Random random)
  {
    return logDensity() - nextExponential(random); 
  }
  
  private static double nextExponential(Random random)
  {
    return - Math.log(random.nextDouble());
  }
  
  private static double nextUniform(Random random, double min, double max)
  {
    return min + random.nextDouble() * (max - min);
  }
  
  private double logDensityAt(double x)
  {
    variable.set(x);
    return logDensity();
  }
  
  private double logDensity() {
    double sum = 0.0;
    for (LogScaleFactor f : numericFactors)
      sum += f.logDensity();
    return sum;
  }
  
  public boolean setup() 
  {
    return true;
  }
}