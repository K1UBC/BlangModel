package blang.distributions

import briefj.collections.UnorderedPair

/** 
 * A normal Markov random field. For small problem, use MultivariateNormal instead, 
 * but for problems with a large, sparse precision matrix, this implementation 
 * allows the user to specify a 'support' 
 * for the precision, outside of which the precision is guaranteed to be zero. This 
 * can speed up sampling considerably.
 */
@SamplerTypes(blang.mcmc.BouncyParticleSampler)
model NormalField {
  
  random Matrix realization
  
  /**
   * precision.support is assumed to be constant.
   */
  param Precision precision
  
  param Matrix mean
    
  laws {
    
    for (UnorderedPair<Integer,Integer> pair : precision.support) {
      logf(
        precision,
        UnorderedPair<Integer,Integer> currentPair = pair,
        RealVar x0 = realization.get(pair.first),
        RealVar x1 = realization.get(pair.second),
        RealVar m0 = mean.get(pair.first),
        RealVar m1 = mean.get(pair.second)
      ) {
        if (currentPair.first === currentPair.second) {
          return - 0.5 * precision.get(currentPair) * (x0 - m0) ** 2
        } else {
          return - precision.get(currentPair) * (x0 - m0) * (x1 - m1)
        }
      }
    }
    
    logf(double dim = realization.nEntries) {
      - dim * log(Math.sqrt(2*Math.PI)) / 2.0
    }
    
    logf(precision) {
      0.5 * precision.logDet
    }
  }
  
  generate (rand) {
    realization.setTo(Generators::multivariateNormal(rand, mean, precision.asMatrix.cholesky))
  }
}