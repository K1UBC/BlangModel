package blang.examples

import blang.types.IntVar
import xlinear.Matrix
import blang.types.RealVar
import java.util.List
import static extension blang.utils.ExtensionUtils.*
import static extension xlinear.MatrixOperations.* 
import blang.types.Simplex
import blang.types.TransitionMatrix

model DynamicNormalMixture  { 
  
  random List<RealVar>     observations 
  random List<IntVar>      states                   ?: listOfIntVars(observations.size)
  
  param  int               nLatentStates            ?: 2
  
  random Simplex           initialDistribution      ?: simplex(nLatentStates)
  random TransitionMatrix  transitionProbabilities  ?: transitionMatrix(nLatentStates)
  random List<RealVar>     means                    ?: listOfRealVars(nLatentStates),
                           variances                ?: listOfRealVars(nLatentStates)
           
  param  RealVar           hyperMean                ?: createConstantReal(0.0), 
                           hyperVariance            ?: createConstantReal(1.0)
  param  RealVar           hyperShape               ?: createConstantReal(1.0),
                           hyperRate                ?: createConstantReal(1.0)
  
  param  Matrix            concentrations           ?: {
    val Matrix result = dense(nLatentStates) // TODO: fix and add ones(..)
    for (i : 0 ..< nLatentStates) {
      result.set(i, 0, 1.0)
    }
    return result
  }        
  
  laws {
    // Priors on initial and transition probabilities
    initialDistribution | concentrations ~ Dirichlet(concentrations)  
    for (int latentStateIdx : 0 ..< means.size) {
      transitionProbabilities.row(latentStateIdx) | concentrations ~ Dirichlet(concentrations)
    }
    
    // Priors on means and variances
    for (int latentStateIdx : 0 ..< means.size) {
      means.get(latentStateIdx)     | hyperMean,  hyperVariance ~ Normal(hyperMean, hyperVariance)
      variances.get(latentStateIdx) | hyperShape, hyperRate     ~ Gamma(hyperShape, hyperRate)
    }
    
    states | initialDistribution, transitionProbabilities  
      ~ MarkovModel(initialDistribution, transitionProbabilities)
      
    // Gaussian emissions
    for (int obsIdx : 0 ..< observations.size) {
      observations.get(obsIdx) |
        means, 
        variances, 
        IntVar curIndic = states.get(obsIdx)
      ~ Normal(means.get(curIndic.intValue), variances.get(curIndic.intValue))
    }
  }
}