package blang.tests.fixtures;

import java.util.List;
import bayonet.distributions.Random;

import blang.core.LogScaleFactor;
import blang.core.WritableRealVar;
import blang.distributions.Generators;
import blang.mcmc.ConnectedFactor;
import blang.mcmc.SampledVariable;
import blang.mcmc.Sampler;
import blang.tests.fixtures.Helpers;


public class BadRealSliceSampler implements Sampler
{
  @SampledVariable
  protected WritableRealVar variable;
  
  @ConnectedFactor
  protected List<LogScaleFactor> numericFactors;
  
  private static final double initialWindowSize = 1.0;
  
  public static BadRealSliceSampler build(WritableRealVar variable, List<LogScaleFactor> numericFactors)
  {
    BadRealSliceSampler result = new BadRealSliceSampler();
    result.variable = variable;
    result.numericFactors = numericFactors;
    return result;
  }
  
  public void execute(Random random)
  {
    Helpers.checkOkToUseDefectiveImplementation();
    
    // sample slice
    final double logSliceHeight = nextSliceHeight(random); // log(Y) in Neal's paper
    final double oldState = variable.doubleValue();        // x0 in Neal's paper
   
    // doubling procedure
    double 
      leftProposalEndPoint = oldState - initialWindowSize * random.nextDouble(), // L in Neal's paper
      rightProposalEndPoint = leftProposalEndPoint + initialWindowSize;          // R in Neal's paper
    
    while (logSliceHeight < logDensityAt(leftProposalEndPoint) || logSliceHeight < logDensityAt(rightProposalEndPoint)) 
      if (random.nextBernoulli(0.5))
      {
        leftProposalEndPoint += - (rightProposalEndPoint - leftProposalEndPoint);
        if (leftProposalEndPoint == Double.NEGATIVE_INFINITY)
          throw new RuntimeException(INFINITE_SLICE_MESSAGE);
      }
      else
      {
        rightProposalEndPoint += rightProposalEndPoint - leftProposalEndPoint;
        if (rightProposalEndPoint == Double.POSITIVE_INFINITY)
          throw new RuntimeException(INFINITE_SLICE_MESSAGE);
      }
    
    // shrinkage procedure
    double 
      leftShrankEndPoint = leftProposalEndPoint,   // bar L in Neal's paper
      rightShrankEndPoint = rightProposalEndPoint; // bar R in Neal's paper
    while (true) 
    {
      final double newState = Generators.uniform(random, leftShrankEndPoint, rightShrankEndPoint); // x1 in Neal's paper
      if (logSliceHeight < logDensityAt(newState) && accept(oldState, newState, logSliceHeight, leftProposalEndPoint, rightProposalEndPoint))
      {
        variable.set(newState);
        return;
      }
      if (newState < oldState)
        leftShrankEndPoint = newState;
      else
        rightShrankEndPoint = newState;
    }
  }
  
  private boolean accept(double oldState, double newState, double logSliceHeight, double leftProposalEndPoint, double rightProposalEndPoint) 
  {
    boolean differ = false; // D in Neal's paper; whether the intervals generated by new and old differ; used for optimization
    while (rightProposalEndPoint - leftProposalEndPoint > 1.1 * initialWindowSize) // 1.1 factor to cover for numerical round offs
    {
      final double middle = (leftProposalEndPoint + rightProposalEndPoint) / 2.0; // M in Neal's paper
      if ((oldState <  middle && newState >= middle) || 
          (oldState >= middle && newState < middle))
        differ = true;
      if (newState < middle)
        rightProposalEndPoint = middle;
      else
        leftProposalEndPoint = middle;
      if (differ && logSliceHeight >= logDensityAt(leftProposalEndPoint) && logSliceHeight >= logDensityAt(rightProposalEndPoint))
        return false;
    }
    return true; 
  }

  private double nextSliceHeight(Random random)
  {
    Helpers.checkOkToUseDefectiveImplementation();
    
    return logDensity() - /** This bit is incorrect! **/ 2.0 * Generators.unitRateExponential(random); 
  }
  
  private double logDensityAt(double x)
  {
    variable.set(x);
    return logDensity();
  }
  
  private double logDensity() {
    double sum = 0.0;
    for (LogScaleFactor f : numericFactors)
      sum += f.logDensity();
    if (Double.isNaN(sum))
      throw new RuntimeException();
    return sum;
  }
  
  public boolean setup() 
  {
    return true;
  }
  
  private static final String INFINITE_SLICE_MESSAGE = "Slice diverged to infinity. "
      + "Possible cause is that a variable has no distribution attached to it, i.e. the model is improper.";
}